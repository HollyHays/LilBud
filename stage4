#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <FastLED.h>
//converts JSON to LCD ready code
#include <ArduinoJson.h>

//connect to WiFi
#include <WiFi.h>
//make HTTP request
#include <HTTPClient.h>

#define BTN_UP 11
#define BTN_DOWN 12
#define BTN_SELECT 13

//LED STRIP CONFIGURATION
//sends data to LED
#define DATA_PIN 28 //#34
//how many leds are on the strip
#define NUM_LEDS 300 //NOT OFFICIAL LED NUM JUST THREW A NUMBER IN FOR NOW
//tells FastLED what protocol the leds use
#define LED_TYPE WS2811
#define COLOR_ORDER GRB //Can change this if the order ends up being a little different
#define BRIGHTNESS 80       //0-255

//LED array
CRGB leds[NUM_LEDS];

//address of flask server: change depending on wifi; runn app.py to get it
const char* SERVER_IP = "172.20.10.9" ; 
//set up wifi
const char* ssid = "iPhone (3)";
const char* password = "Albus1010$";
//test for sending between pot IDs
const char* DEVICE_ID = "lilbud_01";
const char* TARGET_ID = "lilbud_02";

#define MOIST_PIN 26
const int WET_ADC = 750;   
const int DRY_ADC = 900;   
int potMoisture = 0;

constexpr int MENU_COUNT = 3;

enum State{
  refresh,
  send,
  tomohana,
  display,
  end
  };

// Common I2C addresses: 0x27 or 0x3F
LiquidCrystal_I2C lcd(0x27, 16, 2);

bool getButton(int pin){
  if (digitalRead(pin) == LOW){
    while (digitalRead(pin) == LOW){
      delay(250);
    }
    return 1;
  }
  return 0;
}

//function for sending messages
void sendMessage(const char* from_id,const char* to_id, const char* msg) {
  //pico's web messenger
  HTTPClient http;
  //builds the url
  String url = "http://" + String(SERVER_IP) + ":5000/send";

  http.begin(url);
  //sending JSON data since Flask server expects JSON
  http.addHeader("Content-Type", "application/json");
  
  //message format that server understands
  //String payload = "{\"from_id\":\"" + String(device_id) + "\",\"msg\":\"" + String(msg) + "\"}";
  String payload =
    String("{\"from_id\":\"") + from_id +
    "\",\"to_id\":\"" + to_id +
    "\",\"message\":\"" + msg + "\"}";
  
  //checking what we are getting
  Serial.print("POST URL: "); Serial.println(url);
  Serial.print("POST JSON: "); Serial.println(payload);
  
  //sends the message to the server
  int code = http.POST(payload);
  
  //checking
  Serial.print("POST status: "); Serial.println(code);
  String body = http.getString();
  Serial.print("Server says: "); Serial.println(body);
  
  //closes connection and frees memory
  http.end();
}

// Global variable to hold the last received message
String lastMsgText = "";
String lastSender = "";

//function for receiving messages
void checkInbox(const char* device_id) {
  //web browser inside pico
  HTTPClient http;
  //builds url
  String url = "http://" + String(SERVER_IP) + ":5000/inbox?device_id=" + String(device_id);
  
  http.begin(url);
  //sends request: pico --> server
  int code = http.GET();

  //success code (200 = OK)
  if (code == 200) {
    String response = http.getString();
    
    // Create a buffer for the JSON document
    // 512 bytes: plenty for a few short messages
    StaticJsonDocument<512> doc;
    DeserializationError error = deserializeJson(doc, response);

    if (!error) {
      JsonArray messages = doc["messages"];
      
      //If the array isn't empty, extract the first message
      if (messages.size() > 0) {
        lastSender = messages[0]["from_id"].as<String>();
        lastMsgText = messages[0]["message"].as<String>();

        //check
        Serial.println("--- New Message Received ---");
        Serial.print("From: "); Serial.println(lastSender);
        Serial.print("Msg: ");  Serial.println(lastMsgText);
      }
    } else {
      Serial.print("JSON Parse Failed: ");
      Serial.println(error.c_str());
    }
  }

  //closes connection and frees memory
  http.end();
}

const char* menuItems[MENU_COUNT] = {
  "send",
  "display",
  "end"
};

void refreshRead() {
  float currentMoisture = analogRead(1);
  char buffer[10];

  dtostrf(currentMoisture, 6, 2, buffer);

  //UPDATE LIGHTS
  int no_filt = readSensor(); 
  int filt = potMoisture;

  static float drynessSmooth = 0.0f;
  const float colorAlpha = 0.05f; //lower = slower; adjust later

  float dryness = (float)(filt - WET_ADC) / (float)(DRY_ADC - WET_ADC);

  //smooth dryness with filter
  drynessSmooth = (1.0f - colorAlpha) * drynessSmooth + colorAlpha * dryness;

  //turns dryness to color, using FastLED
  CRGB color;
  color.r = 255*drynessSmooth;
  color.g = 0;
  color.b = 255*(1.0f - drynessSmooth);

  //send data to leds
  fill_solid(leds, NUM_LEDS, color);
  FastLED.show();

  // lcd.clear();
  // lcd.setCursor(0, 1);
  // lcd.print(buffer);

  // delay(1500);
}

int updatePosi(int posi, int mod) {
  return (posi + mod + MENU_COUNT) % MENU_COUNT;
}

void updateMenu(int pos) {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(menuItems[pos]);
}

void usermenu() {
  static State menuState = tomohana;  // persists across calls
  static int posi = 0;
  const char* alert = "Help me";

  switch (menuState) {

    case send:
      refreshRead();
      lcd.setCursor(0,0);
      lcd.print(alert);
      sendMessage(DEVICE_ID, TARGET_ID, alert);

      delay(1000);
      menuState = tomohana;
      break;

    case display:
      refreshRead();
      checkInbox(DEVICE_ID);
      
      lcd.clear();
      if (lastMsgText != "") {
        lcd.setCursor(0,0);
        lcd.print(lastMsgText); //only show message text
        lastMsgText = ""; //clear the variable
      }
      //wait until select button is pushed to exit the message
      while(!getButton(BTN_SELECT)){
        delay(10);
      }
      menuState = tomohana;
      break;

    case tomohana:
      updateMenu(posi);

      while (true) {
        if (getButton(BTN_UP)) {
          posi = updatePosi(posi, 1);
          updateMenu(posi);
        }

        if (getButton(BTN_DOWN)) {
          posi = updatePosi(posi, -1);
          updateMenu(posi);
        }

        if (getButton(BTN_SELECT)) {
          switch (posi) {
            case 0:
              menuState = send;
              break;
            case 1:
              menuState = display;
              break;
            case 2:
              menuState = tomohana;
              break; // idle?
            case 3:
              menuState = end;
              break;
          }
          break;
        }

        delay(10);  // debounce / CPU relief
      }
      break;

    case end:
      lcd.clear();
      lcd.print("Exiting...");
      while (!getButton(BTN_DOWN)) {
        delay(10);
      }
      menuState = tomohana;
      break;
  }
}

int alphafilter(float nMoisture, float potMoisture = 0){
  float alpha = 0.4;
  float fMoisture = (nMoisture*alpha + (1-alpha)*potMoisture);
  return fMoisture;
}

int readSensor(){
  int cMoisture = analogRead(MOIST_PIN);
  potMoisture = alphafilter(cMoisture);
  return cMoisture;
}

void setup() {
  // Serial.begin(115200);
  delay(1000);
  //button pins config
  pinMode(BTN_UP, INPUT_PULLUP);
  pinMode(BTN_DOWN, INPUT_PULLUP);
  pinMode(BTN_SELECT, INPUT_PULLUP);
  //WIFI SETUP
  WiFi.begin(ssid, password);
  
  //LCD SETUP
  // Wire.setSDA(4);
  // Wire.setSCL(5);          // Uses A4 (SDA), A5 (SCL) on Uno
  Wire.begin();
  lcd.init();            // Initialize LCD
  lcd.backlight();       // Turn on backlight

  lcd.clear();
  lcd.setCursor(0, 0);   // Column 0, Row 0
  lcd.print("Welcome to");

  lcd.setCursor(0, 1);   // Column 0, Row 1
  lcd.print("Lil' Bud");

  //LED SETUP
  //tells FastLED all the info
  FastLED.addLeds<LED_TYPE, DATA_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  FastLED.setBrightness(BRIGHTNESS);
  //sets all leds to turn off
  FastLED.clear();
  //sends data from pico to strip
  FastLED.show();
}

void loop() {
  lcd.clear();
  //lcd.print("Hello there1");
  delay(1500);
  while(!getButton(BTN_SELECT)){
    refreshRead();
  }
  usermenu();

}
